/*
SpaceTraders API

SpaceTraders is an open-universe game and learning platform that offers a set of HTTP endpoints to control a fleet of ships and explore a multiplayer universe.  The API is documented using [OpenAPI](https://github.com/SpaceTradersAPI/api-docs). You can send your first request right here in your browser to check the status of the game server.  ```json http {   \"method\": \"GET\",   \"url\": \"https://api.spacetraders.io/v2\", } ```  Unlike a traditional game, SpaceTraders does not have a first-party client or app to play the game. Instead, you can use the API to build your own client, write a script to automate your ships, or try an app built by the community.  We have a [Discord channel](https://discord.com/invite/jh6zurdWk5) where you can share your projects, ask questions, and get help from other players.

API version: 2.0.0
Contact: joel@spacetraders.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package st

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type FleetAPI interface {

	/*
		CreateChart Create Chart

		Command a ship to chart the waypoint at its current location.

	Most waypoints in the universe are uncharted by default. These waypoints have their traits hidden until they have been charted by a ship.

	Charting a waypoint will record your agent as the one who created the chart, and all other agents would also be able to see the waypoint's traits.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param shipSymbol The symbol of the ship.
		@return FleetAPICreateChartRequest
	*/
	CreateChart(ctx context.Context, shipSymbol string) FleetAPICreateChartRequest

	// CreateChartExecute executes the request
	//  @return CreateChart201Response
	CreateChartExecute(r FleetAPICreateChartRequest) (*CreateChart201Response, *http.Response, error)

	/*
		CreateShipShipScan Scan Ships

		Scan for nearby ships, retrieving information for all ships in range.

	Requires a ship to have the `Sensor Array` mount installed to use.

	The ship will enter a cooldown after using this function, during which it cannot execute certain actions.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param shipSymbol The ship symbol.
		@return FleetAPICreateShipShipScanRequest
	*/
	CreateShipShipScan(ctx context.Context, shipSymbol string) FleetAPICreateShipShipScanRequest

	// CreateShipShipScanExecute executes the request
	//  @return CreateShipShipScan201Response
	CreateShipShipScanExecute(r FleetAPICreateShipShipScanRequest) (*CreateShipShipScan201Response, *http.Response, error)

	/*
		CreateShipSystemScan Scan Systems

		Scan for nearby systems, retrieving information on the systems' distance from the ship and their waypoints. Requires a ship to have the `Sensor Array` mount installed to use.

	The ship will enter a cooldown after using this function, during which it cannot execute certain actions.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param shipSymbol The ship symbol.
		@return FleetAPICreateShipSystemScanRequest
	*/
	CreateShipSystemScan(ctx context.Context, shipSymbol string) FleetAPICreateShipSystemScanRequest

	// CreateShipSystemScanExecute executes the request
	//  @return CreateShipSystemScan201Response
	CreateShipSystemScanExecute(r FleetAPICreateShipSystemScanRequest) (*CreateShipSystemScan201Response, *http.Response, error)

	/*
		CreateShipWaypointScan Scan Waypoints

		Scan for nearby waypoints, retrieving detailed information on each waypoint in range. Scanning uncharted waypoints will allow you to ignore their uncharted state and will list the waypoints' traits.

	Requires a ship to have the `Sensor Array` mount installed to use.

	The ship will enter a cooldown after using this function, during which it cannot execute certain actions.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param shipSymbol The ship symbol.
		@return FleetAPICreateShipWaypointScanRequest
	*/
	CreateShipWaypointScan(ctx context.Context, shipSymbol string) FleetAPICreateShipWaypointScanRequest

	// CreateShipWaypointScanExecute executes the request
	//  @return CreateShipWaypointScan201Response
	CreateShipWaypointScanExecute(r FleetAPICreateShipWaypointScanRequest) (*CreateShipWaypointScan201Response, *http.Response, error)

	/*
		CreateSurvey Create Survey

		Create surveys on a waypoint that can be extracted such as asteroid fields. A survey focuses on specific types of deposits from the extracted location. When ships extract using this survey, they are guaranteed to procure a high amount of one of the goods in the survey.

	In order to use a survey, send the entire survey details in the body of the extract request.

	Each survey may have multiple deposits, and if a symbol shows up more than once, that indicates a higher chance of extracting that resource.

	Your ship will enter a cooldown after surveying in which it is unable to perform certain actions. Surveys will eventually expire after a period of time or will be exhausted after being extracted several times based on the survey's size. Multiple ships can use the same survey for extraction.

	A ship must have the `Surveyor` mount installed in order to use this function.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param shipSymbol The symbol of the ship.
		@return FleetAPICreateSurveyRequest
	*/
	CreateSurvey(ctx context.Context, shipSymbol string) FleetAPICreateSurveyRequest

	// CreateSurveyExecute executes the request
	//  @return CreateSurvey201Response
	CreateSurveyExecute(r FleetAPICreateSurveyRequest) (*CreateSurvey201Response, *http.Response, error)

	/*
		DockShip Dock Ship

		Attempt to dock your ship at its current location. Docking will only succeed if your ship is capable of docking at the time of the request.

	Docked ships can access elements in their current location, such as the market or a shipyard, but cannot do actions that require the ship to be above surface such as navigating or extracting.

	The endpoint is idempotent - successive calls will succeed even if the ship is already docked.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param shipSymbol The symbol of the ship.
		@return FleetAPIDockShipRequest
	*/
	DockShip(ctx context.Context, shipSymbol string) FleetAPIDockShipRequest

	// DockShipExecute executes the request
	//  @return DockShip200Response
	DockShipExecute(r FleetAPIDockShipRequest) (*DockShip200Response, *http.Response, error)

	/*
		ExtractResources Extract Resources

		Extract resources from a waypoint that can be extracted, such as asteroid fields, into your ship. Send an optional survey as the payload to target specific yields.

	The ship must be in orbit to be able to extract and must have mining equipments installed that can extract goods, such as the `Gas Siphon` mount for gas-based goods or `Mining Laser` mount for ore-based goods.

	The survey property is now deprecated. See the `extract/survey` endpoint for more details.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param shipSymbol The ship symbol.
		@return FleetAPIExtractResourcesRequest
	*/
	ExtractResources(ctx context.Context, shipSymbol string) FleetAPIExtractResourcesRequest

	// ExtractResourcesExecute executes the request
	//  @return ExtractResources201Response
	ExtractResourcesExecute(r FleetAPIExtractResourcesRequest) (*ExtractResources201Response, *http.Response, error)

	/*
		ExtractResourcesWithSurvey Extract Resources with Survey

		Use a survey when extracting resources from a waypoint. This endpoint requires a survey as the payload, which allows your ship to extract specific yields.

	Send the full survey object as the payload which will be validated according to the signature. If the signature is invalid, or any properties of the survey are changed, the request will fail.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param shipSymbol The ship symbol.
		@return FleetAPIExtractResourcesWithSurveyRequest
	*/
	ExtractResourcesWithSurvey(ctx context.Context, shipSymbol string) FleetAPIExtractResourcesWithSurveyRequest

	// ExtractResourcesWithSurveyExecute executes the request
	//  @return ExtractResources201Response
	ExtractResourcesWithSurveyExecute(r FleetAPIExtractResourcesWithSurveyRequest) (*ExtractResources201Response, *http.Response, error)

	/*
		GetMounts Get Mounts

		Get the mounts installed on a ship.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param shipSymbol The ship's symbol.
		@return FleetAPIGetMountsRequest
	*/
	GetMounts(ctx context.Context, shipSymbol string) FleetAPIGetMountsRequest

	// GetMountsExecute executes the request
	//  @return GetMounts200Response
	GetMountsExecute(r FleetAPIGetMountsRequest) (*GetMounts200Response, *http.Response, error)

	/*
		GetMyShip Get Ship

		Retrieve the details of a ship under your agent's ownership.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param shipSymbol The symbol of the ship.
		@return FleetAPIGetMyShipRequest
	*/
	GetMyShip(ctx context.Context, shipSymbol string) FleetAPIGetMyShipRequest

	// GetMyShipExecute executes the request
	//  @return GetMyShip200Response
	GetMyShipExecute(r FleetAPIGetMyShipRequest) (*GetMyShip200Response, *http.Response, error)

	/*
		GetMyShipCargo Get Ship Cargo

		Retrieve the cargo of a ship under your agent's ownership.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param shipSymbol The symbol of the ship.
		@return FleetAPIGetMyShipCargoRequest
	*/
	GetMyShipCargo(ctx context.Context, shipSymbol string) FleetAPIGetMyShipCargoRequest

	// GetMyShipCargoExecute executes the request
	//  @return GetMyShipCargo200Response
	GetMyShipCargoExecute(r FleetAPIGetMyShipCargoRequest) (*GetMyShipCargo200Response, *http.Response, error)

	/*
		GetMyShips List Ships

		Return a paginated list of all of ships under your agent's ownership.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return FleetAPIGetMyShipsRequest
	*/
	GetMyShips(ctx context.Context) FleetAPIGetMyShipsRequest

	// GetMyShipsExecute executes the request
	//  @return GetMyShips200Response
	GetMyShipsExecute(r FleetAPIGetMyShipsRequest) (*GetMyShips200Response, *http.Response, error)

	/*
		GetRepairShip Get Repair Ship

		Get the cost of repairing a ship.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param shipSymbol The ship symbol.
		@return FleetAPIGetRepairShipRequest
	*/
	GetRepairShip(ctx context.Context, shipSymbol string) FleetAPIGetRepairShipRequest

	// GetRepairShipExecute executes the request
	//  @return GetRepairShip200Response
	GetRepairShipExecute(r FleetAPIGetRepairShipRequest) (*GetRepairShip200Response, *http.Response, error)

	/*
		GetScrapShip Get Scrap Ship

		Get the amount of value that will be returned when scrapping a ship.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param shipSymbol The ship symbol.
		@return FleetAPIGetScrapShipRequest
	*/
	GetScrapShip(ctx context.Context, shipSymbol string) FleetAPIGetScrapShipRequest

	// GetScrapShipExecute executes the request
	//  @return GetScrapShip200Response
	GetScrapShipExecute(r FleetAPIGetScrapShipRequest) (*GetScrapShip200Response, *http.Response, error)

	/*
		GetShipCooldown Get Ship Cooldown

		Retrieve the details of your ship's reactor cooldown. Some actions such as activating your jump drive, scanning, or extracting resources taxes your reactor and results in a cooldown.

	Your ship cannot perform additional actions until your cooldown has expired. The duration of your cooldown is relative to the power consumption of the related modules or mounts for the action taken.

	Response returns a 204 status code (no-content) when the ship has no cooldown.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param shipSymbol The symbol of the ship.
		@return FleetAPIGetShipCooldownRequest
	*/
	GetShipCooldown(ctx context.Context, shipSymbol string) FleetAPIGetShipCooldownRequest

	// GetShipCooldownExecute executes the request
	//  @return GetShipCooldown200Response
	GetShipCooldownExecute(r FleetAPIGetShipCooldownRequest) (*GetShipCooldown200Response, *http.Response, error)

	/*
		GetShipNav Get Ship Nav

		Get the current nav status of a ship.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param shipSymbol The ship symbol.
		@return FleetAPIGetShipNavRequest
	*/
	GetShipNav(ctx context.Context, shipSymbol string) FleetAPIGetShipNavRequest

	// GetShipNavExecute executes the request
	//  @return GetShipNav200Response
	GetShipNavExecute(r FleetAPIGetShipNavRequest) (*GetShipNav200Response, *http.Response, error)

	/*
		InstallMount Install Mount

		Install a mount on a ship.

	In order to install a mount, the ship must be docked and located in a waypoint that has a `Shipyard` trait. The ship also must have the mount to install in its cargo hold.

	An installation fee will be deduced by the Shipyard for installing the mount on the ship.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param shipSymbol The ship's symbol.
		@return FleetAPIInstallMountRequest
	*/
	InstallMount(ctx context.Context, shipSymbol string) FleetAPIInstallMountRequest

	// InstallMountExecute executes the request
	//  @return InstallMount201Response
	InstallMountExecute(r FleetAPIInstallMountRequest) (*InstallMount201Response, *http.Response, error)

	/*
		Jettison Jettison Cargo

		Jettison cargo from your ship's cargo hold.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param shipSymbol The ship symbol.
		@return FleetAPIJettisonRequest
	*/
	Jettison(ctx context.Context, shipSymbol string) FleetAPIJettisonRequest

	// JettisonExecute executes the request
	//  @return Jettison200Response
	JettisonExecute(r FleetAPIJettisonRequest) (*Jettison200Response, *http.Response, error)

	/*
		JumpShip Jump Ship

		Jump your ship instantly to a target connected waypoint. The ship must be in orbit to execute a jump.

	A unit of antimatter is purchased and consumed from the market when jumping. The price of antimatter is determined by the market and is subject to change. A ship can only jump to connected waypoints

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param shipSymbol The ship symbol.
		@return FleetAPIJumpShipRequest
	*/
	JumpShip(ctx context.Context, shipSymbol string) FleetAPIJumpShipRequest

	// JumpShipExecute executes the request
	//  @return JumpShip200Response
	JumpShipExecute(r FleetAPIJumpShipRequest) (*JumpShip200Response, *http.Response, error)

	/*
		NavigateShip Navigate Ship

		Navigate to a target destination. The ship must be in orbit to use this function. The destination waypoint must be within the same system as the ship's current location. Navigating will consume the necessary fuel from the ship's manifest based on the distance to the target waypoint.

	The returned response will detail the route information including the expected time of arrival. Most ship actions are unavailable until the ship has arrived at it's destination.

	To travel between systems, see the ship's Warp or Jump actions.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param shipSymbol The ship symbol.
		@return FleetAPINavigateShipRequest
	*/
	NavigateShip(ctx context.Context, shipSymbol string) FleetAPINavigateShipRequest

	// NavigateShipExecute executes the request
	//  @return NavigateShip200Response
	NavigateShipExecute(r FleetAPINavigateShipRequest) (*NavigateShip200Response, *http.Response, error)

	/*
		NegotiateContract Negotiate Contract

		Negotiate a new contract with the HQ.

	In order to negotiate a new contract, an agent must not have ongoing or offered contracts over the allowed maximum amount. Currently the maximum contracts an agent can have at a time is 1.

	Once a contract is negotiated, it is added to the list of contracts offered to the agent, which the agent can then accept.

	The ship must be present at any waypoint with a faction present to negotiate a contract with that faction.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param shipSymbol The ship's symbol.
		@return FleetAPINegotiateContractRequest
	*/
	NegotiateContract(ctx context.Context, shipSymbol string) FleetAPINegotiateContractRequest

	// NegotiateContractExecute executes the request
	//  @return NegotiateContract200Response
	NegotiateContractExecute(r FleetAPINegotiateContractRequest) (*NegotiateContract200Response, *http.Response, error)

	/*
		OrbitShip Orbit Ship

		Attempt to move your ship into orbit at its current location. The request will only succeed if your ship is capable of moving into orbit at the time of the request.

	Orbiting ships are able to do actions that require the ship to be above surface such as navigating or extracting, but cannot access elements in their current waypoint, such as the market or a shipyard.

	The endpoint is idempotent - successive calls will succeed even if the ship is already in orbit.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param shipSymbol The symbol of the ship.
		@return FleetAPIOrbitShipRequest
	*/
	OrbitShip(ctx context.Context, shipSymbol string) FleetAPIOrbitShipRequest

	// OrbitShipExecute executes the request
	//  @return OrbitShip200Response
	OrbitShipExecute(r FleetAPIOrbitShipRequest) (*OrbitShip200Response, *http.Response, error)

	/*
		PatchShipNav Patch Ship Nav

		Update the nav configuration of a ship.

	Currently only supports configuring the Flight Mode of the ship, which affects its speed and fuel consumption.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param shipSymbol The ship symbol.
		@return FleetAPIPatchShipNavRequest
	*/
	PatchShipNav(ctx context.Context, shipSymbol string) FleetAPIPatchShipNavRequest

	// PatchShipNavExecute executes the request
	//  @return GetShipNav200Response
	PatchShipNavExecute(r FleetAPIPatchShipNavRequest) (*GetShipNav200Response, *http.Response, error)

	/*
		PurchaseCargo Purchase Cargo

		Purchase cargo from a market.

	The ship must be docked in a waypoint that has `Marketplace` trait, and the market must be selling a good to be able to purchase it.

	The maximum amount of units of a good that can be purchased in each transaction are denoted by the `tradeVolume` value of the good, which can be viewed by using the Get Market action.

	Purchased goods are added to the ship's cargo hold.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param shipSymbol The ship's symbol.
		@return FleetAPIPurchaseCargoRequest
	*/
	PurchaseCargo(ctx context.Context, shipSymbol string) FleetAPIPurchaseCargoRequest

	// PurchaseCargoExecute executes the request
	//  @return PurchaseCargo201Response
	PurchaseCargoExecute(r FleetAPIPurchaseCargoRequest) (*PurchaseCargo201Response, *http.Response, error)

	/*
		PurchaseShip Purchase Ship

		Purchase a ship from a Shipyard. In order to use this function, a ship under your agent's ownership must be in a waypoint that has the `Shipyard` trait, and the Shipyard must sell the type of the desired ship.

	Shipyards typically offer ship types, which are predefined templates of ships that have dedicated roles. A template comes with a preset of an engine, a reactor, and a frame. It may also include a few modules and mounts.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return FleetAPIPurchaseShipRequest
	*/
	PurchaseShip(ctx context.Context) FleetAPIPurchaseShipRequest

	// PurchaseShipExecute executes the request
	//  @return PurchaseShip201Response
	PurchaseShipExecute(r FleetAPIPurchaseShipRequest) (*PurchaseShip201Response, *http.Response, error)

	/*
		RefuelShip Refuel Ship

		Refuel your ship by buying fuel from the local market.

	Requires the ship to be docked in a waypoint that has the `Marketplace` trait, and the market must be selling fuel in order to refuel.

	Each fuel bought from the market replenishes 100 units in your ship's fuel.

	Ships will always be refuel to their frame's maximum fuel capacity when using this action.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param shipSymbol The ship symbol.
		@return FleetAPIRefuelShipRequest
	*/
	RefuelShip(ctx context.Context, shipSymbol string) FleetAPIRefuelShipRequest

	// RefuelShipExecute executes the request
	//  @return RefuelShip200Response
	RefuelShipExecute(r FleetAPIRefuelShipRequest) (*RefuelShip200Response, *http.Response, error)

	/*
		RemoveMount Remove Mount

		Remove a mount from a ship.

	The ship must be docked in a waypoint that has the `Shipyard` trait, and must have the desired mount that it wish to remove installed.

	A removal fee will be deduced from the agent by the Shipyard.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param shipSymbol The ship's symbol.
		@return FleetAPIRemoveMountRequest
	*/
	RemoveMount(ctx context.Context, shipSymbol string) FleetAPIRemoveMountRequest

	// RemoveMountExecute executes the request
	//  @return RemoveMount201Response
	RemoveMountExecute(r FleetAPIRemoveMountRequest) (*RemoveMount201Response, *http.Response, error)

	/*
		RepairShip Repair Ship

		Repair a ship, restoring the ship to maximum condition. The ship must be docked at a waypoint that has the `Shipyard` trait in order to use this function. To preview the cost of repairing the ship, use the Get action.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param shipSymbol The ship symbol.
		@return FleetAPIRepairShipRequest
	*/
	RepairShip(ctx context.Context, shipSymbol string) FleetAPIRepairShipRequest

	// RepairShipExecute executes the request
	//  @return RepairShip200Response
	RepairShipExecute(r FleetAPIRepairShipRequest) (*RepairShip200Response, *http.Response, error)

	/*
		ScrapShip Scrap Ship

		Scrap a ship, removing it from the game and returning a portion of the ship's value to the agent. The ship must be docked in a waypoint that has the `Shipyard` trait in order to use this function. To preview the amount of value that will be returned, use the Get Ship action.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param shipSymbol The ship symbol.
		@return FleetAPIScrapShipRequest
	*/
	ScrapShip(ctx context.Context, shipSymbol string) FleetAPIScrapShipRequest

	// ScrapShipExecute executes the request
	//  @return ScrapShip200Response
	ScrapShipExecute(r FleetAPIScrapShipRequest) (*ScrapShip200Response, *http.Response, error)

	/*
		SellCargo Sell Cargo

		Sell cargo in your ship to a market that trades this cargo. The ship must be docked in a waypoint that has the `Marketplace` trait in order to use this function.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param shipSymbol Symbol of a ship.
		@return FleetAPISellCargoRequest
	*/
	SellCargo(ctx context.Context, shipSymbol string) FleetAPISellCargoRequest

	// SellCargoExecute executes the request
	//  @return SellCargo201Response
	SellCargoExecute(r FleetAPISellCargoRequest) (*SellCargo201Response, *http.Response, error)

	/*
		ShipRefine Ship Refine

		Attempt to refine the raw materials on your ship. The request will only succeed if your ship is capable of refining at the time of the request. In order to be able to refine, a ship must have goods that can be refined and have installed a `Refinery` module that can refine it.

	When refining, 30 basic goods will be converted into 10 processed goods.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param shipSymbol The symbol of the ship.
		@return FleetAPIShipRefineRequest
	*/
	ShipRefine(ctx context.Context, shipSymbol string) FleetAPIShipRefineRequest

	// ShipRefineExecute executes the request
	//  @return ShipRefine201Response
	ShipRefineExecute(r FleetAPIShipRefineRequest) (*ShipRefine201Response, *http.Response, error)

	/*
		SiphonResources Siphon Resources

		Siphon gases, such as hydrocarbon, from gas giants.

	The ship must be in orbit to be able to siphon and must have siphon mounts and a gas processor installed.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param shipSymbol The ship symbol.
		@return FleetAPISiphonResourcesRequest
	*/
	SiphonResources(ctx context.Context, shipSymbol string) FleetAPISiphonResourcesRequest

	// SiphonResourcesExecute executes the request
	//  @return SiphonResources201Response
	SiphonResourcesExecute(r FleetAPISiphonResourcesRequest) (*SiphonResources201Response, *http.Response, error)

	/*
		TransferCargo Transfer Cargo

		Transfer cargo between ships.

	The receiving ship must be in the same waypoint as the transferring ship, and it must able to hold the additional cargo after the transfer is complete. Both ships also must be in the same state, either both are docked or both are orbiting.

	The response body's cargo shows the cargo of the transferring ship after the transfer is complete.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param shipSymbol The transferring ship's symbol.
		@return FleetAPITransferCargoRequest
	*/
	TransferCargo(ctx context.Context, shipSymbol string) FleetAPITransferCargoRequest

	// TransferCargoExecute executes the request
	//  @return TransferCargo200Response
	TransferCargoExecute(r FleetAPITransferCargoRequest) (*TransferCargo200Response, *http.Response, error)

	/*
		WarpShip Warp Ship

		Warp your ship to a target destination in another system. The ship must be in orbit to use this function and must have the `Warp Drive` module installed. Warping will consume the necessary fuel from the ship's manifest.

	The returned response will detail the route information including the expected time of arrival. Most ship actions are unavailable until the ship has arrived at its destination.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param shipSymbol The ship symbol.
		@return FleetAPIWarpShipRequest
	*/
	WarpShip(ctx context.Context, shipSymbol string) FleetAPIWarpShipRequest

	// WarpShipExecute executes the request
	//  @return WarpShip200Response
	WarpShipExecute(r FleetAPIWarpShipRequest) (*WarpShip200Response, *http.Response, error)
}

// FleetAPIService FleetAPI service
type FleetAPIService service

type FleetAPICreateChartRequest struct {
	ctx        context.Context
	ApiService FleetAPI
	shipSymbol string
}

func (r FleetAPICreateChartRequest) Execute() (*CreateChart201Response, *http.Response, error) {
	return r.ApiService.CreateChartExecute(r)
}

/*
CreateChart Create Chart

Command a ship to chart the waypoint at its current location.

Most waypoints in the universe are uncharted by default. These waypoints have their traits hidden until they have been charted by a ship.

Charting a waypoint will record your agent as the one who created the chart, and all other agents would also be able to see the waypoint's traits.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The symbol of the ship.
	@return FleetAPICreateChartRequest
*/
func (a *FleetAPIService) CreateChart(ctx context.Context, shipSymbol string) FleetAPICreateChartRequest {
	return FleetAPICreateChartRequest{
		ApiService: a,
		ctx:        ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//
//	@return CreateChart201Response
func (a *FleetAPIService) CreateChartExecute(r FleetAPICreateChartRequest) (*CreateChart201Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreateChart201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetAPIService.CreateChart")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/chart"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FleetAPICreateShipShipScanRequest struct {
	ctx        context.Context
	ApiService FleetAPI
	shipSymbol string
}

func (r FleetAPICreateShipShipScanRequest) Execute() (*CreateShipShipScan201Response, *http.Response, error) {
	return r.ApiService.CreateShipShipScanExecute(r)
}

/*
CreateShipShipScan Scan Ships

Scan for nearby ships, retrieving information for all ships in range.

Requires a ship to have the `Sensor Array` mount installed to use.

The ship will enter a cooldown after using this function, during which it cannot execute certain actions.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The ship symbol.
	@return FleetAPICreateShipShipScanRequest
*/
func (a *FleetAPIService) CreateShipShipScan(ctx context.Context, shipSymbol string) FleetAPICreateShipShipScanRequest {
	return FleetAPICreateShipShipScanRequest{
		ApiService: a,
		ctx:        ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//
//	@return CreateShipShipScan201Response
func (a *FleetAPIService) CreateShipShipScanExecute(r FleetAPICreateShipShipScanRequest) (*CreateShipShipScan201Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreateShipShipScan201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetAPIService.CreateShipShipScan")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/scan/ships"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FleetAPICreateShipSystemScanRequest struct {
	ctx        context.Context
	ApiService FleetAPI
	shipSymbol string
}

func (r FleetAPICreateShipSystemScanRequest) Execute() (*CreateShipSystemScan201Response, *http.Response, error) {
	return r.ApiService.CreateShipSystemScanExecute(r)
}

/*
CreateShipSystemScan Scan Systems

Scan for nearby systems, retrieving information on the systems' distance from the ship and their waypoints. Requires a ship to have the `Sensor Array` mount installed to use.

The ship will enter a cooldown after using this function, during which it cannot execute certain actions.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The ship symbol.
	@return FleetAPICreateShipSystemScanRequest
*/
func (a *FleetAPIService) CreateShipSystemScan(ctx context.Context, shipSymbol string) FleetAPICreateShipSystemScanRequest {
	return FleetAPICreateShipSystemScanRequest{
		ApiService: a,
		ctx:        ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//
//	@return CreateShipSystemScan201Response
func (a *FleetAPIService) CreateShipSystemScanExecute(r FleetAPICreateShipSystemScanRequest) (*CreateShipSystemScan201Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreateShipSystemScan201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetAPIService.CreateShipSystemScan")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/scan/systems"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FleetAPICreateShipWaypointScanRequest struct {
	ctx        context.Context
	ApiService FleetAPI
	shipSymbol string
}

func (r FleetAPICreateShipWaypointScanRequest) Execute() (*CreateShipWaypointScan201Response, *http.Response, error) {
	return r.ApiService.CreateShipWaypointScanExecute(r)
}

/*
CreateShipWaypointScan Scan Waypoints

Scan for nearby waypoints, retrieving detailed information on each waypoint in range. Scanning uncharted waypoints will allow you to ignore their uncharted state and will list the waypoints' traits.

Requires a ship to have the `Sensor Array` mount installed to use.

The ship will enter a cooldown after using this function, during which it cannot execute certain actions.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The ship symbol.
	@return FleetAPICreateShipWaypointScanRequest
*/
func (a *FleetAPIService) CreateShipWaypointScan(ctx context.Context, shipSymbol string) FleetAPICreateShipWaypointScanRequest {
	return FleetAPICreateShipWaypointScanRequest{
		ApiService: a,
		ctx:        ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//
//	@return CreateShipWaypointScan201Response
func (a *FleetAPIService) CreateShipWaypointScanExecute(r FleetAPICreateShipWaypointScanRequest) (*CreateShipWaypointScan201Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreateShipWaypointScan201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetAPIService.CreateShipWaypointScan")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/scan/waypoints"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FleetAPICreateSurveyRequest struct {
	ctx        context.Context
	ApiService FleetAPI
	shipSymbol string
}

func (r FleetAPICreateSurveyRequest) Execute() (*CreateSurvey201Response, *http.Response, error) {
	return r.ApiService.CreateSurveyExecute(r)
}

/*
CreateSurvey Create Survey

Create surveys on a waypoint that can be extracted such as asteroid fields. A survey focuses on specific types of deposits from the extracted location. When ships extract using this survey, they are guaranteed to procure a high amount of one of the goods in the survey.

In order to use a survey, send the entire survey details in the body of the extract request.

Each survey may have multiple deposits, and if a symbol shows up more than once, that indicates a higher chance of extracting that resource.

Your ship will enter a cooldown after surveying in which it is unable to perform certain actions. Surveys will eventually expire after a period of time or will be exhausted after being extracted several times based on the survey's size. Multiple ships can use the same survey for extraction.

A ship must have the `Surveyor` mount installed in order to use this function.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The symbol of the ship.
	@return FleetAPICreateSurveyRequest
*/
func (a *FleetAPIService) CreateSurvey(ctx context.Context, shipSymbol string) FleetAPICreateSurveyRequest {
	return FleetAPICreateSurveyRequest{
		ApiService: a,
		ctx:        ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//
//	@return CreateSurvey201Response
func (a *FleetAPIService) CreateSurveyExecute(r FleetAPICreateSurveyRequest) (*CreateSurvey201Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreateSurvey201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetAPIService.CreateSurvey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/survey"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FleetAPIDockShipRequest struct {
	ctx        context.Context
	ApiService FleetAPI
	shipSymbol string
}

func (r FleetAPIDockShipRequest) Execute() (*DockShip200Response, *http.Response, error) {
	return r.ApiService.DockShipExecute(r)
}

/*
DockShip Dock Ship

Attempt to dock your ship at its current location. Docking will only succeed if your ship is capable of docking at the time of the request.

Docked ships can access elements in their current location, such as the market or a shipyard, but cannot do actions that require the ship to be above surface such as navigating or extracting.

The endpoint is idempotent - successive calls will succeed even if the ship is already docked.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The symbol of the ship.
	@return FleetAPIDockShipRequest
*/
func (a *FleetAPIService) DockShip(ctx context.Context, shipSymbol string) FleetAPIDockShipRequest {
	return FleetAPIDockShipRequest{
		ApiService: a,
		ctx:        ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//
//	@return DockShip200Response
func (a *FleetAPIService) DockShipExecute(r FleetAPIDockShipRequest) (*DockShip200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DockShip200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetAPIService.DockShip")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/dock"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FleetAPIExtractResourcesRequest struct {
	ctx                     context.Context
	ApiService              FleetAPI
	shipSymbol              string
	extractResourcesRequest *ExtractResourcesRequest
}

func (r FleetAPIExtractResourcesRequest) ExtractResourcesRequest(extractResourcesRequest ExtractResourcesRequest) FleetAPIExtractResourcesRequest {
	r.extractResourcesRequest = &extractResourcesRequest
	return r
}

func (r FleetAPIExtractResourcesRequest) Execute() (*ExtractResources201Response, *http.Response, error) {
	return r.ApiService.ExtractResourcesExecute(r)
}

/*
ExtractResources Extract Resources

Extract resources from a waypoint that can be extracted, such as asteroid fields, into your ship. Send an optional survey as the payload to target specific yields.

The ship must be in orbit to be able to extract and must have mining equipments installed that can extract goods, such as the `Gas Siphon` mount for gas-based goods or `Mining Laser` mount for ore-based goods.

The survey property is now deprecated. See the `extract/survey` endpoint for more details.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The ship symbol.
	@return FleetAPIExtractResourcesRequest
*/
func (a *FleetAPIService) ExtractResources(ctx context.Context, shipSymbol string) FleetAPIExtractResourcesRequest {
	return FleetAPIExtractResourcesRequest{
		ApiService: a,
		ctx:        ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//
//	@return ExtractResources201Response
func (a *FleetAPIService) ExtractResourcesExecute(r FleetAPIExtractResourcesRequest) (*ExtractResources201Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ExtractResources201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetAPIService.ExtractResources")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/extract"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.extractResourcesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FleetAPIExtractResourcesWithSurveyRequest struct {
	ctx        context.Context
	ApiService FleetAPI
	shipSymbol string
	survey     *Survey
}

func (r FleetAPIExtractResourcesWithSurveyRequest) Survey(survey Survey) FleetAPIExtractResourcesWithSurveyRequest {
	r.survey = &survey
	return r
}

func (r FleetAPIExtractResourcesWithSurveyRequest) Execute() (*ExtractResources201Response, *http.Response, error) {
	return r.ApiService.ExtractResourcesWithSurveyExecute(r)
}

/*
ExtractResourcesWithSurvey Extract Resources with Survey

Use a survey when extracting resources from a waypoint. This endpoint requires a survey as the payload, which allows your ship to extract specific yields.

Send the full survey object as the payload which will be validated according to the signature. If the signature is invalid, or any properties of the survey are changed, the request will fail.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The ship symbol.
	@return FleetAPIExtractResourcesWithSurveyRequest
*/
func (a *FleetAPIService) ExtractResourcesWithSurvey(ctx context.Context, shipSymbol string) FleetAPIExtractResourcesWithSurveyRequest {
	return FleetAPIExtractResourcesWithSurveyRequest{
		ApiService: a,
		ctx:        ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//
//	@return ExtractResources201Response
func (a *FleetAPIService) ExtractResourcesWithSurveyExecute(r FleetAPIExtractResourcesWithSurveyRequest) (*ExtractResources201Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ExtractResources201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetAPIService.ExtractResourcesWithSurvey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/extract/survey"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.survey
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FleetAPIGetMountsRequest struct {
	ctx        context.Context
	ApiService FleetAPI
	shipSymbol string
}

func (r FleetAPIGetMountsRequest) Execute() (*GetMounts200Response, *http.Response, error) {
	return r.ApiService.GetMountsExecute(r)
}

/*
GetMounts Get Mounts

Get the mounts installed on a ship.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The ship's symbol.
	@return FleetAPIGetMountsRequest
*/
func (a *FleetAPIService) GetMounts(ctx context.Context, shipSymbol string) FleetAPIGetMountsRequest {
	return FleetAPIGetMountsRequest{
		ApiService: a,
		ctx:        ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//
//	@return GetMounts200Response
func (a *FleetAPIService) GetMountsExecute(r FleetAPIGetMountsRequest) (*GetMounts200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetMounts200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetAPIService.GetMounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/mounts"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FleetAPIGetMyShipRequest struct {
	ctx        context.Context
	ApiService FleetAPI
	shipSymbol string
}

func (r FleetAPIGetMyShipRequest) Execute() (*GetMyShip200Response, *http.Response, error) {
	return r.ApiService.GetMyShipExecute(r)
}

/*
GetMyShip Get Ship

Retrieve the details of a ship under your agent's ownership.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The symbol of the ship.
	@return FleetAPIGetMyShipRequest
*/
func (a *FleetAPIService) GetMyShip(ctx context.Context, shipSymbol string) FleetAPIGetMyShipRequest {
	return FleetAPIGetMyShipRequest{
		ApiService: a,
		ctx:        ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//
//	@return GetMyShip200Response
func (a *FleetAPIService) GetMyShipExecute(r FleetAPIGetMyShipRequest) (*GetMyShip200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetMyShip200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetAPIService.GetMyShip")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FleetAPIGetMyShipCargoRequest struct {
	ctx        context.Context
	ApiService FleetAPI
	shipSymbol string
}

func (r FleetAPIGetMyShipCargoRequest) Execute() (*GetMyShipCargo200Response, *http.Response, error) {
	return r.ApiService.GetMyShipCargoExecute(r)
}

/*
GetMyShipCargo Get Ship Cargo

Retrieve the cargo of a ship under your agent's ownership.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The symbol of the ship.
	@return FleetAPIGetMyShipCargoRequest
*/
func (a *FleetAPIService) GetMyShipCargo(ctx context.Context, shipSymbol string) FleetAPIGetMyShipCargoRequest {
	return FleetAPIGetMyShipCargoRequest{
		ApiService: a,
		ctx:        ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//
//	@return GetMyShipCargo200Response
func (a *FleetAPIService) GetMyShipCargoExecute(r FleetAPIGetMyShipCargoRequest) (*GetMyShipCargo200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetMyShipCargo200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetAPIService.GetMyShipCargo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/cargo"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FleetAPIGetMyShipsRequest struct {
	ctx        context.Context
	ApiService FleetAPI
	page       *int32
	limit      *int32
}

// What entry offset to request
func (r FleetAPIGetMyShipsRequest) Page(page int32) FleetAPIGetMyShipsRequest {
	r.page = &page
	return r
}

// How many entries to return per page
func (r FleetAPIGetMyShipsRequest) Limit(limit int32) FleetAPIGetMyShipsRequest {
	r.limit = &limit
	return r
}

func (r FleetAPIGetMyShipsRequest) Execute() (*GetMyShips200Response, *http.Response, error) {
	return r.ApiService.GetMyShipsExecute(r)
}

/*
GetMyShips List Ships

Return a paginated list of all of ships under your agent's ownership.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return FleetAPIGetMyShipsRequest
*/
func (a *FleetAPIService) GetMyShips(ctx context.Context) FleetAPIGetMyShipsRequest {
	return FleetAPIGetMyShipsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetMyShips200Response
func (a *FleetAPIService) GetMyShipsExecute(r FleetAPIGetMyShipsRequest) (*GetMyShips200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetMyShips200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetAPIService.GetMyShips")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 10
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FleetAPIGetRepairShipRequest struct {
	ctx        context.Context
	ApiService FleetAPI
	shipSymbol string
}

func (r FleetAPIGetRepairShipRequest) Execute() (*GetRepairShip200Response, *http.Response, error) {
	return r.ApiService.GetRepairShipExecute(r)
}

/*
GetRepairShip Get Repair Ship

Get the cost of repairing a ship.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The ship symbol.
	@return FleetAPIGetRepairShipRequest
*/
func (a *FleetAPIService) GetRepairShip(ctx context.Context, shipSymbol string) FleetAPIGetRepairShipRequest {
	return FleetAPIGetRepairShipRequest{
		ApiService: a,
		ctx:        ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//
//	@return GetRepairShip200Response
func (a *FleetAPIService) GetRepairShipExecute(r FleetAPIGetRepairShipRequest) (*GetRepairShip200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetRepairShip200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetAPIService.GetRepairShip")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/repair"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FleetAPIGetScrapShipRequest struct {
	ctx        context.Context
	ApiService FleetAPI
	shipSymbol string
}

func (r FleetAPIGetScrapShipRequest) Execute() (*GetScrapShip200Response, *http.Response, error) {
	return r.ApiService.GetScrapShipExecute(r)
}

/*
GetScrapShip Get Scrap Ship

Get the amount of value that will be returned when scrapping a ship.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The ship symbol.
	@return FleetAPIGetScrapShipRequest
*/
func (a *FleetAPIService) GetScrapShip(ctx context.Context, shipSymbol string) FleetAPIGetScrapShipRequest {
	return FleetAPIGetScrapShipRequest{
		ApiService: a,
		ctx:        ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//
//	@return GetScrapShip200Response
func (a *FleetAPIService) GetScrapShipExecute(r FleetAPIGetScrapShipRequest) (*GetScrapShip200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetScrapShip200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetAPIService.GetScrapShip")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/scrap"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FleetAPIGetShipCooldownRequest struct {
	ctx        context.Context
	ApiService FleetAPI
	shipSymbol string
}

func (r FleetAPIGetShipCooldownRequest) Execute() (*GetShipCooldown200Response, *http.Response, error) {
	return r.ApiService.GetShipCooldownExecute(r)
}

/*
GetShipCooldown Get Ship Cooldown

Retrieve the details of your ship's reactor cooldown. Some actions such as activating your jump drive, scanning, or extracting resources taxes your reactor and results in a cooldown.

Your ship cannot perform additional actions until your cooldown has expired. The duration of your cooldown is relative to the power consumption of the related modules or mounts for the action taken.

Response returns a 204 status code (no-content) when the ship has no cooldown.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The symbol of the ship.
	@return FleetAPIGetShipCooldownRequest
*/
func (a *FleetAPIService) GetShipCooldown(ctx context.Context, shipSymbol string) FleetAPIGetShipCooldownRequest {
	return FleetAPIGetShipCooldownRequest{
		ApiService: a,
		ctx:        ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//
//	@return GetShipCooldown200Response
func (a *FleetAPIService) GetShipCooldownExecute(r FleetAPIGetShipCooldownRequest) (*GetShipCooldown200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetShipCooldown200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetAPIService.GetShipCooldown")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/cooldown"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FleetAPIGetShipNavRequest struct {
	ctx        context.Context
	ApiService FleetAPI
	shipSymbol string
}

func (r FleetAPIGetShipNavRequest) Execute() (*GetShipNav200Response, *http.Response, error) {
	return r.ApiService.GetShipNavExecute(r)
}

/*
GetShipNav Get Ship Nav

Get the current nav status of a ship.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The ship symbol.
	@return FleetAPIGetShipNavRequest
*/
func (a *FleetAPIService) GetShipNav(ctx context.Context, shipSymbol string) FleetAPIGetShipNavRequest {
	return FleetAPIGetShipNavRequest{
		ApiService: a,
		ctx:        ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//
//	@return GetShipNav200Response
func (a *FleetAPIService) GetShipNavExecute(r FleetAPIGetShipNavRequest) (*GetShipNav200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetShipNav200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetAPIService.GetShipNav")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/nav"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FleetAPIInstallMountRequest struct {
	ctx                 context.Context
	ApiService          FleetAPI
	shipSymbol          string
	installMountRequest *InstallMountRequest
}

func (r FleetAPIInstallMountRequest) InstallMountRequest(installMountRequest InstallMountRequest) FleetAPIInstallMountRequest {
	r.installMountRequest = &installMountRequest
	return r
}

func (r FleetAPIInstallMountRequest) Execute() (*InstallMount201Response, *http.Response, error) {
	return r.ApiService.InstallMountExecute(r)
}

/*
InstallMount Install Mount

Install a mount on a ship.

In order to install a mount, the ship must be docked and located in a waypoint that has a `Shipyard` trait. The ship also must have the mount to install in its cargo hold.

An installation fee will be deduced by the Shipyard for installing the mount on the ship.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The ship's symbol.
	@return FleetAPIInstallMountRequest
*/
func (a *FleetAPIService) InstallMount(ctx context.Context, shipSymbol string) FleetAPIInstallMountRequest {
	return FleetAPIInstallMountRequest{
		ApiService: a,
		ctx:        ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//
//	@return InstallMount201Response
func (a *FleetAPIService) InstallMountExecute(r FleetAPIInstallMountRequest) (*InstallMount201Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InstallMount201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetAPIService.InstallMount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/mounts/install"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.installMountRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FleetAPIJettisonRequest struct {
	ctx             context.Context
	ApiService      FleetAPI
	shipSymbol      string
	jettisonRequest *JettisonRequest
}

func (r FleetAPIJettisonRequest) JettisonRequest(jettisonRequest JettisonRequest) FleetAPIJettisonRequest {
	r.jettisonRequest = &jettisonRequest
	return r
}

func (r FleetAPIJettisonRequest) Execute() (*Jettison200Response, *http.Response, error) {
	return r.ApiService.JettisonExecute(r)
}

/*
Jettison Jettison Cargo

Jettison cargo from your ship's cargo hold.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The ship symbol.
	@return FleetAPIJettisonRequest
*/
func (a *FleetAPIService) Jettison(ctx context.Context, shipSymbol string) FleetAPIJettisonRequest {
	return FleetAPIJettisonRequest{
		ApiService: a,
		ctx:        ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//
//	@return Jettison200Response
func (a *FleetAPIService) JettisonExecute(r FleetAPIJettisonRequest) (*Jettison200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Jettison200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetAPIService.Jettison")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/jettison"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jettisonRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FleetAPIJumpShipRequest struct {
	ctx             context.Context
	ApiService      FleetAPI
	shipSymbol      string
	jumpShipRequest *JumpShipRequest
}

func (r FleetAPIJumpShipRequest) JumpShipRequest(jumpShipRequest JumpShipRequest) FleetAPIJumpShipRequest {
	r.jumpShipRequest = &jumpShipRequest
	return r
}

func (r FleetAPIJumpShipRequest) Execute() (*JumpShip200Response, *http.Response, error) {
	return r.ApiService.JumpShipExecute(r)
}

/*
JumpShip Jump Ship

Jump your ship instantly to a target connected waypoint. The ship must be in orbit to execute a jump.

A unit of antimatter is purchased and consumed from the market when jumping. The price of antimatter is determined by the market and is subject to change. A ship can only jump to connected waypoints

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The ship symbol.
	@return FleetAPIJumpShipRequest
*/
func (a *FleetAPIService) JumpShip(ctx context.Context, shipSymbol string) FleetAPIJumpShipRequest {
	return FleetAPIJumpShipRequest{
		ApiService: a,
		ctx:        ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//
//	@return JumpShip200Response
func (a *FleetAPIService) JumpShipExecute(r FleetAPIJumpShipRequest) (*JumpShip200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *JumpShip200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetAPIService.JumpShip")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/jump"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jumpShipRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FleetAPINavigateShipRequest struct {
	ctx                 context.Context
	ApiService          FleetAPI
	shipSymbol          string
	navigateShipRequest *NavigateShipRequest
}

func (r FleetAPINavigateShipRequest) NavigateShipRequest(navigateShipRequest NavigateShipRequest) FleetAPINavigateShipRequest {
	r.navigateShipRequest = &navigateShipRequest
	return r
}

func (r FleetAPINavigateShipRequest) Execute() (*NavigateShip200Response, *http.Response, error) {
	return r.ApiService.NavigateShipExecute(r)
}

/*
NavigateShip Navigate Ship

Navigate to a target destination. The ship must be in orbit to use this function. The destination waypoint must be within the same system as the ship's current location. Navigating will consume the necessary fuel from the ship's manifest based on the distance to the target waypoint.

The returned response will detail the route information including the expected time of arrival. Most ship actions are unavailable until the ship has arrived at it's destination.

To travel between systems, see the ship's Warp or Jump actions.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The ship symbol.
	@return FleetAPINavigateShipRequest
*/
func (a *FleetAPIService) NavigateShip(ctx context.Context, shipSymbol string) FleetAPINavigateShipRequest {
	return FleetAPINavigateShipRequest{
		ApiService: a,
		ctx:        ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//
//	@return NavigateShip200Response
func (a *FleetAPIService) NavigateShipExecute(r FleetAPINavigateShipRequest) (*NavigateShip200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NavigateShip200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetAPIService.NavigateShip")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/navigate"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.navigateShipRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FleetAPINegotiateContractRequest struct {
	ctx        context.Context
	ApiService FleetAPI
	shipSymbol string
}

func (r FleetAPINegotiateContractRequest) Execute() (*NegotiateContract200Response, *http.Response, error) {
	return r.ApiService.NegotiateContractExecute(r)
}

/*
NegotiateContract Negotiate Contract

Negotiate a new contract with the HQ.

In order to negotiate a new contract, an agent must not have ongoing or offered contracts over the allowed maximum amount. Currently the maximum contracts an agent can have at a time is 1.

Once a contract is negotiated, it is added to the list of contracts offered to the agent, which the agent can then accept.

The ship must be present at any waypoint with a faction present to negotiate a contract with that faction.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The ship's symbol.
	@return FleetAPINegotiateContractRequest
*/
func (a *FleetAPIService) NegotiateContract(ctx context.Context, shipSymbol string) FleetAPINegotiateContractRequest {
	return FleetAPINegotiateContractRequest{
		ApiService: a,
		ctx:        ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//
//	@return NegotiateContract200Response
func (a *FleetAPIService) NegotiateContractExecute(r FleetAPINegotiateContractRequest) (*NegotiateContract200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NegotiateContract200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetAPIService.NegotiateContract")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/negotiate/contract"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FleetAPIOrbitShipRequest struct {
	ctx        context.Context
	ApiService FleetAPI
	shipSymbol string
}

func (r FleetAPIOrbitShipRequest) Execute() (*OrbitShip200Response, *http.Response, error) {
	return r.ApiService.OrbitShipExecute(r)
}

/*
OrbitShip Orbit Ship

Attempt to move your ship into orbit at its current location. The request will only succeed if your ship is capable of moving into orbit at the time of the request.

Orbiting ships are able to do actions that require the ship to be above surface such as navigating or extracting, but cannot access elements in their current waypoint, such as the market or a shipyard.

The endpoint is idempotent - successive calls will succeed even if the ship is already in orbit.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The symbol of the ship.
	@return FleetAPIOrbitShipRequest
*/
func (a *FleetAPIService) OrbitShip(ctx context.Context, shipSymbol string) FleetAPIOrbitShipRequest {
	return FleetAPIOrbitShipRequest{
		ApiService: a,
		ctx:        ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//
//	@return OrbitShip200Response
func (a *FleetAPIService) OrbitShipExecute(r FleetAPIOrbitShipRequest) (*OrbitShip200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OrbitShip200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetAPIService.OrbitShip")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/orbit"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FleetAPIPatchShipNavRequest struct {
	ctx                 context.Context
	ApiService          FleetAPI
	shipSymbol          string
	patchShipNavRequest *PatchShipNavRequest
}

func (r FleetAPIPatchShipNavRequest) PatchShipNavRequest(patchShipNavRequest PatchShipNavRequest) FleetAPIPatchShipNavRequest {
	r.patchShipNavRequest = &patchShipNavRequest
	return r
}

func (r FleetAPIPatchShipNavRequest) Execute() (*GetShipNav200Response, *http.Response, error) {
	return r.ApiService.PatchShipNavExecute(r)
}

/*
PatchShipNav Patch Ship Nav

Update the nav configuration of a ship.

Currently only supports configuring the Flight Mode of the ship, which affects its speed and fuel consumption.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The ship symbol.
	@return FleetAPIPatchShipNavRequest
*/
func (a *FleetAPIService) PatchShipNav(ctx context.Context, shipSymbol string) FleetAPIPatchShipNavRequest {
	return FleetAPIPatchShipNavRequest{
		ApiService: a,
		ctx:        ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//
//	@return GetShipNav200Response
func (a *FleetAPIService) PatchShipNavExecute(r FleetAPIPatchShipNavRequest) (*GetShipNav200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetShipNav200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetAPIService.PatchShipNav")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/nav"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchShipNavRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FleetAPIPurchaseCargoRequest struct {
	ctx                  context.Context
	ApiService           FleetAPI
	shipSymbol           string
	purchaseCargoRequest *PurchaseCargoRequest
}

func (r FleetAPIPurchaseCargoRequest) PurchaseCargoRequest(purchaseCargoRequest PurchaseCargoRequest) FleetAPIPurchaseCargoRequest {
	r.purchaseCargoRequest = &purchaseCargoRequest
	return r
}

func (r FleetAPIPurchaseCargoRequest) Execute() (*PurchaseCargo201Response, *http.Response, error) {
	return r.ApiService.PurchaseCargoExecute(r)
}

/*
PurchaseCargo Purchase Cargo

Purchase cargo from a market.

The ship must be docked in a waypoint that has `Marketplace` trait, and the market must be selling a good to be able to purchase it.

The maximum amount of units of a good that can be purchased in each transaction are denoted by the `tradeVolume` value of the good, which can be viewed by using the Get Market action.

Purchased goods are added to the ship's cargo hold.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The ship's symbol.
	@return FleetAPIPurchaseCargoRequest
*/
func (a *FleetAPIService) PurchaseCargo(ctx context.Context, shipSymbol string) FleetAPIPurchaseCargoRequest {
	return FleetAPIPurchaseCargoRequest{
		ApiService: a,
		ctx:        ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//
//	@return PurchaseCargo201Response
func (a *FleetAPIService) PurchaseCargoExecute(r FleetAPIPurchaseCargoRequest) (*PurchaseCargo201Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PurchaseCargo201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetAPIService.PurchaseCargo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/purchase"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.purchaseCargoRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FleetAPIPurchaseShipRequest struct {
	ctx                 context.Context
	ApiService          FleetAPI
	purchaseShipRequest *PurchaseShipRequest
}

func (r FleetAPIPurchaseShipRequest) PurchaseShipRequest(purchaseShipRequest PurchaseShipRequest) FleetAPIPurchaseShipRequest {
	r.purchaseShipRequest = &purchaseShipRequest
	return r
}

func (r FleetAPIPurchaseShipRequest) Execute() (*PurchaseShip201Response, *http.Response, error) {
	return r.ApiService.PurchaseShipExecute(r)
}

/*
PurchaseShip Purchase Ship

Purchase a ship from a Shipyard. In order to use this function, a ship under your agent's ownership must be in a waypoint that has the `Shipyard` trait, and the Shipyard must sell the type of the desired ship.

Shipyards typically offer ship types, which are predefined templates of ships that have dedicated roles. A template comes with a preset of an engine, a reactor, and a frame. It may also include a few modules and mounts.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return FleetAPIPurchaseShipRequest
*/
func (a *FleetAPIService) PurchaseShip(ctx context.Context) FleetAPIPurchaseShipRequest {
	return FleetAPIPurchaseShipRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PurchaseShip201Response
func (a *FleetAPIService) PurchaseShipExecute(r FleetAPIPurchaseShipRequest) (*PurchaseShip201Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PurchaseShip201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetAPIService.PurchaseShip")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.purchaseShipRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FleetAPIRefuelShipRequest struct {
	ctx               context.Context
	ApiService        FleetAPI
	shipSymbol        string
	refuelShipRequest *RefuelShipRequest
}

func (r FleetAPIRefuelShipRequest) RefuelShipRequest(refuelShipRequest RefuelShipRequest) FleetAPIRefuelShipRequest {
	r.refuelShipRequest = &refuelShipRequest
	return r
}

func (r FleetAPIRefuelShipRequest) Execute() (*RefuelShip200Response, *http.Response, error) {
	return r.ApiService.RefuelShipExecute(r)
}

/*
RefuelShip Refuel Ship

Refuel your ship by buying fuel from the local market.

Requires the ship to be docked in a waypoint that has the `Marketplace` trait, and the market must be selling fuel in order to refuel.

Each fuel bought from the market replenishes 100 units in your ship's fuel.

Ships will always be refuel to their frame's maximum fuel capacity when using this action.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The ship symbol.
	@return FleetAPIRefuelShipRequest
*/
func (a *FleetAPIService) RefuelShip(ctx context.Context, shipSymbol string) FleetAPIRefuelShipRequest {
	return FleetAPIRefuelShipRequest{
		ApiService: a,
		ctx:        ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//
//	@return RefuelShip200Response
func (a *FleetAPIService) RefuelShipExecute(r FleetAPIRefuelShipRequest) (*RefuelShip200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RefuelShip200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetAPIService.RefuelShip")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/refuel"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.refuelShipRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FleetAPIRemoveMountRequest struct {
	ctx                context.Context
	ApiService         FleetAPI
	shipSymbol         string
	removeMountRequest *RemoveMountRequest
}

func (r FleetAPIRemoveMountRequest) RemoveMountRequest(removeMountRequest RemoveMountRequest) FleetAPIRemoveMountRequest {
	r.removeMountRequest = &removeMountRequest
	return r
}

func (r FleetAPIRemoveMountRequest) Execute() (*RemoveMount201Response, *http.Response, error) {
	return r.ApiService.RemoveMountExecute(r)
}

/*
RemoveMount Remove Mount

Remove a mount from a ship.

The ship must be docked in a waypoint that has the `Shipyard` trait, and must have the desired mount that it wish to remove installed.

A removal fee will be deduced from the agent by the Shipyard.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The ship's symbol.
	@return FleetAPIRemoveMountRequest
*/
func (a *FleetAPIService) RemoveMount(ctx context.Context, shipSymbol string) FleetAPIRemoveMountRequest {
	return FleetAPIRemoveMountRequest{
		ApiService: a,
		ctx:        ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//
//	@return RemoveMount201Response
func (a *FleetAPIService) RemoveMountExecute(r FleetAPIRemoveMountRequest) (*RemoveMount201Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RemoveMount201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetAPIService.RemoveMount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/mounts/remove"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.removeMountRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FleetAPIRepairShipRequest struct {
	ctx        context.Context
	ApiService FleetAPI
	shipSymbol string
}

func (r FleetAPIRepairShipRequest) Execute() (*RepairShip200Response, *http.Response, error) {
	return r.ApiService.RepairShipExecute(r)
}

/*
RepairShip Repair Ship

Repair a ship, restoring the ship to maximum condition. The ship must be docked at a waypoint that has the `Shipyard` trait in order to use this function. To preview the cost of repairing the ship, use the Get action.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The ship symbol.
	@return FleetAPIRepairShipRequest
*/
func (a *FleetAPIService) RepairShip(ctx context.Context, shipSymbol string) FleetAPIRepairShipRequest {
	return FleetAPIRepairShipRequest{
		ApiService: a,
		ctx:        ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//
//	@return RepairShip200Response
func (a *FleetAPIService) RepairShipExecute(r FleetAPIRepairShipRequest) (*RepairShip200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RepairShip200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetAPIService.RepairShip")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/repair"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FleetAPIScrapShipRequest struct {
	ctx        context.Context
	ApiService FleetAPI
	shipSymbol string
}

func (r FleetAPIScrapShipRequest) Execute() (*ScrapShip200Response, *http.Response, error) {
	return r.ApiService.ScrapShipExecute(r)
}

/*
ScrapShip Scrap Ship

Scrap a ship, removing it from the game and returning a portion of the ship's value to the agent. The ship must be docked in a waypoint that has the `Shipyard` trait in order to use this function. To preview the amount of value that will be returned, use the Get Ship action.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The ship symbol.
	@return FleetAPIScrapShipRequest
*/
func (a *FleetAPIService) ScrapShip(ctx context.Context, shipSymbol string) FleetAPIScrapShipRequest {
	return FleetAPIScrapShipRequest{
		ApiService: a,
		ctx:        ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//
//	@return ScrapShip200Response
func (a *FleetAPIService) ScrapShipExecute(r FleetAPIScrapShipRequest) (*ScrapShip200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ScrapShip200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetAPIService.ScrapShip")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/scrap"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FleetAPISellCargoRequest struct {
	ctx              context.Context
	ApiService       FleetAPI
	shipSymbol       string
	sellCargoRequest *SellCargoRequest
}

func (r FleetAPISellCargoRequest) SellCargoRequest(sellCargoRequest SellCargoRequest) FleetAPISellCargoRequest {
	r.sellCargoRequest = &sellCargoRequest
	return r
}

func (r FleetAPISellCargoRequest) Execute() (*SellCargo201Response, *http.Response, error) {
	return r.ApiService.SellCargoExecute(r)
}

/*
SellCargo Sell Cargo

Sell cargo in your ship to a market that trades this cargo. The ship must be docked in a waypoint that has the `Marketplace` trait in order to use this function.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol Symbol of a ship.
	@return FleetAPISellCargoRequest
*/
func (a *FleetAPIService) SellCargo(ctx context.Context, shipSymbol string) FleetAPISellCargoRequest {
	return FleetAPISellCargoRequest{
		ApiService: a,
		ctx:        ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//
//	@return SellCargo201Response
func (a *FleetAPIService) SellCargoExecute(r FleetAPISellCargoRequest) (*SellCargo201Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SellCargo201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetAPIService.SellCargo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/sell"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sellCargoRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FleetAPIShipRefineRequest struct {
	ctx               context.Context
	ApiService        FleetAPI
	shipSymbol        string
	shipRefineRequest *ShipRefineRequest
}

func (r FleetAPIShipRefineRequest) ShipRefineRequest(shipRefineRequest ShipRefineRequest) FleetAPIShipRefineRequest {
	r.shipRefineRequest = &shipRefineRequest
	return r
}

func (r FleetAPIShipRefineRequest) Execute() (*ShipRefine201Response, *http.Response, error) {
	return r.ApiService.ShipRefineExecute(r)
}

/*
ShipRefine Ship Refine

Attempt to refine the raw materials on your ship. The request will only succeed if your ship is capable of refining at the time of the request. In order to be able to refine, a ship must have goods that can be refined and have installed a `Refinery` module that can refine it.

When refining, 30 basic goods will be converted into 10 processed goods.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The symbol of the ship.
	@return FleetAPIShipRefineRequest
*/
func (a *FleetAPIService) ShipRefine(ctx context.Context, shipSymbol string) FleetAPIShipRefineRequest {
	return FleetAPIShipRefineRequest{
		ApiService: a,
		ctx:        ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//
//	@return ShipRefine201Response
func (a *FleetAPIService) ShipRefineExecute(r FleetAPIShipRefineRequest) (*ShipRefine201Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ShipRefine201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetAPIService.ShipRefine")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/refine"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.shipRefineRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FleetAPISiphonResourcesRequest struct {
	ctx        context.Context
	ApiService FleetAPI
	shipSymbol string
}

func (r FleetAPISiphonResourcesRequest) Execute() (*SiphonResources201Response, *http.Response, error) {
	return r.ApiService.SiphonResourcesExecute(r)
}

/*
SiphonResources Siphon Resources

Siphon gases, such as hydrocarbon, from gas giants.

The ship must be in orbit to be able to siphon and must have siphon mounts and a gas processor installed.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The ship symbol.
	@return FleetAPISiphonResourcesRequest
*/
func (a *FleetAPIService) SiphonResources(ctx context.Context, shipSymbol string) FleetAPISiphonResourcesRequest {
	return FleetAPISiphonResourcesRequest{
		ApiService: a,
		ctx:        ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//
//	@return SiphonResources201Response
func (a *FleetAPIService) SiphonResourcesExecute(r FleetAPISiphonResourcesRequest) (*SiphonResources201Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SiphonResources201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetAPIService.SiphonResources")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/siphon"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FleetAPITransferCargoRequest struct {
	ctx                  context.Context
	ApiService           FleetAPI
	shipSymbol           string
	transferCargoRequest *TransferCargoRequest
}

func (r FleetAPITransferCargoRequest) TransferCargoRequest(transferCargoRequest TransferCargoRequest) FleetAPITransferCargoRequest {
	r.transferCargoRequest = &transferCargoRequest
	return r
}

func (r FleetAPITransferCargoRequest) Execute() (*TransferCargo200Response, *http.Response, error) {
	return r.ApiService.TransferCargoExecute(r)
}

/*
TransferCargo Transfer Cargo

Transfer cargo between ships.

The receiving ship must be in the same waypoint as the transferring ship, and it must able to hold the additional cargo after the transfer is complete. Both ships also must be in the same state, either both are docked or both are orbiting.

The response body's cargo shows the cargo of the transferring ship after the transfer is complete.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The transferring ship's symbol.
	@return FleetAPITransferCargoRequest
*/
func (a *FleetAPIService) TransferCargo(ctx context.Context, shipSymbol string) FleetAPITransferCargoRequest {
	return FleetAPITransferCargoRequest{
		ApiService: a,
		ctx:        ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//
//	@return TransferCargo200Response
func (a *FleetAPIService) TransferCargoExecute(r FleetAPITransferCargoRequest) (*TransferCargo200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TransferCargo200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetAPIService.TransferCargo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/transfer"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.transferCargoRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FleetAPIWarpShipRequest struct {
	ctx                 context.Context
	ApiService          FleetAPI
	shipSymbol          string
	navigateShipRequest *NavigateShipRequest
}

func (r FleetAPIWarpShipRequest) NavigateShipRequest(navigateShipRequest NavigateShipRequest) FleetAPIWarpShipRequest {
	r.navigateShipRequest = &navigateShipRequest
	return r
}

func (r FleetAPIWarpShipRequest) Execute() (*WarpShip200Response, *http.Response, error) {
	return r.ApiService.WarpShipExecute(r)
}

/*
WarpShip Warp Ship

Warp your ship to a target destination in another system. The ship must be in orbit to use this function and must have the `Warp Drive` module installed. Warping will consume the necessary fuel from the ship's manifest.

The returned response will detail the route information including the expected time of arrival. Most ship actions are unavailable until the ship has arrived at its destination.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The ship symbol.
	@return FleetAPIWarpShipRequest
*/
func (a *FleetAPIService) WarpShip(ctx context.Context, shipSymbol string) FleetAPIWarpShipRequest {
	return FleetAPIWarpShipRequest{
		ApiService: a,
		ctx:        ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//
//	@return WarpShip200Response
func (a *FleetAPIService) WarpShipExecute(r FleetAPIWarpShipRequest) (*WarpShip200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WarpShip200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetAPIService.WarpShip")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/warp"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.navigateShipRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
